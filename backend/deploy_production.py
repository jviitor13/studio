#!/usr/bin/env python3
"""
Script de deploy para produ√ß√£o - RodoCheck Backend
Este script automatiza o processo de deploy em ambiente de produ√ß√£o.
"""

import os
import sys
import subprocess
import logging
from pathlib import Path
from typing import List, Dict, Any

# Configurar logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)


class ProductionDeployer:
    """
    Classe para gerenciar o deploy de produ√ß√£o.
    """
    
    def __init__(self, project_root: str = None):
        """
        Inicializa o deployer.
        
        Args:
            project_root: Caminho raiz do projeto
        """
        self.project_root = Path(project_root) if project_root else Path(__file__).parent
        self.venv_path = self.project_root / 'venv'
        self.requirements_file = self.project_root / 'requirements-production.txt'
        self.env_file = self.project_root / '.env'
        
    def deploy(self) -> bool:
        """
        Executa o processo completo de deploy.
        
        Returns:
            bool: True se o deploy foi bem-sucedido
        """
        try:
            logger.info("üöÄ Iniciando deploy de produ√ß√£o...")
            
            # 1. Validar ambiente
            if not self._validate_environment():
                logger.error("‚ùå Valida√ß√£o de ambiente falhou")
                return False
            
            # 2. Backup do banco de dados
            if not self._backup_database():
                logger.error("‚ùå Backup do banco de dados falhou")
                return False
            
            # 3. Atualizar depend√™ncias
            if not self._update_dependencies():
                logger.error("‚ùå Atualiza√ß√£o de depend√™ncias falhou")
                return False
            
            # 4. Executar migra√ß√µes
            if not self._run_migrations():
                logger.error("‚ùå Migra√ß√µes falharam")
                return False
            
            # 5. Coletar arquivos est√°ticos
            if not self._collect_static_files():
                logger.error("‚ùå Coleta de arquivos est√°ticos falhou")
                return False
            
            # 6. Reiniciar servi√ßos
            if not self._restart_services():
                logger.error("‚ùå Reinicializa√ß√£o de servi√ßos falhou")
                return False
            
            # 7. Verificar sa√∫de da aplica√ß√£o
            if not self._health_check():
                logger.error("‚ùå Verifica√ß√£o de sa√∫de falhou")
                return False
            
            logger.info("‚úÖ Deploy de produ√ß√£o conclu√≠do com sucesso!")
            return True
            
        except Exception as e:
            logger.error(f"‚ùå Erro durante o deploy: {e}")
            return False
    
    def _validate_environment(self) -> bool:
        """
        Valida se o ambiente est√° configurado corretamente.
        
        Returns:
            bool: True se v√°lido
        """
        logger.info("üîç Validando ambiente...")
        
        # Verificar se estamos em produ√ß√£o
        if os.environ.get('DJANGO_SETTINGS_MODULE') != 'rodocheck_backend.settings_production':
            logger.warning("‚ö†Ô∏è  DJANGO_SETTINGS_MODULE n√£o est√° configurado para produ√ß√£o")
        
        # Verificar vari√°veis obrigat√≥rias
        required_vars = [
            'SECRET_KEY',
            'DB_NAME',
            'DB_USER',
            'DB_PASSWORD',
            'DB_HOST',
            'GOOGLE_OAUTH_CLIENT_ID',
            'GOOGLE_OAUTH_CLIENT_SECRET',
        ]
        
        missing_vars = []
        for var in required_vars:
            if not os.environ.get(var):
                missing_vars.append(var)
        
        if missing_vars:
            logger.error(f"‚ùå Vari√°veis de ambiente obrigat√≥rias n√£o definidas: {missing_vars}")
            return False
        
        logger.info("‚úÖ Ambiente validado com sucesso")
        return True
    
    def _backup_database(self) -> bool:
        """
        Cria backup do banco de dados.
        
        Returns:
            bool: True se backup foi bem-sucedido
        """
        logger.info("üíæ Criando backup do banco de dados...")
        
        try:
            # Criar diret√≥rio de backup se n√£o existir
            backup_dir = self.project_root / 'backups'
            backup_dir.mkdir(exist_ok=True)
            
            # Nome do arquivo de backup
            from datetime import datetime
            timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
            backup_file = backup_dir / f'backup_{timestamp}.sql'
            
            # Comando de backup PostgreSQL
            db_name = os.environ.get('DB_NAME')
            db_user = os.environ.get('DB_USER')
            db_host = os.environ.get('DB_HOST')
            
            cmd = [
                'pg_dump',
                '-h', db_host,
                '-U', db_user,
                '-d', db_name,
                '-f', str(backup_file)
            ]
            
            # Executar backup
            result = subprocess.run(cmd, capture_output=True, text=True)
            
            if result.returncode == 0:
                logger.info(f"‚úÖ Backup criado: {backup_file}")
                return True
            else:
                logger.error(f"‚ùå Erro no backup: {result.stderr}")
                return False
                
        except Exception as e:
            logger.error(f"‚ùå Erro ao criar backup: {e}")
            return False
    
    def _update_dependencies(self) -> bool:
        """
        Atualiza depend√™ncias do Python.
        
        Returns:
            bool: True se atualiza√ß√£o foi bem-sucedida
        """
        logger.info("üì¶ Atualizando depend√™ncias...")
        
        try:
            # Ativar ambiente virtual
            if sys.platform == 'win32':
                activate_script = self.venv_path / 'Scripts' / 'activate.bat'
                pip_cmd = str(self.venv_path / 'Scripts' / 'pip.exe')
            else:
                activate_script = self.venv_path / 'bin' / 'activate'
                pip_cmd = str(self.venv_path / 'bin' / 'pip')
            
            # Instalar depend√™ncias de produ√ß√£o
            cmd = [pip_cmd, 'install', '-r', str(self.requirements_file)]
            
            result = subprocess.run(cmd, capture_output=True, text=True)
            
            if result.returncode == 0:
                logger.info("‚úÖ Depend√™ncias atualizadas com sucesso")
                return True
            else:
                logger.error(f"‚ùå Erro ao atualizar depend√™ncias: {result.stderr}")
                return False
                
        except Exception as e:
            logger.error(f"‚ùå Erro ao atualizar depend√™ncias: {e}")
            return False
    
    def _run_migrations(self) -> bool:
        """
        Executa migra√ß√µes do Django.
        
        Returns:
            bool: True se migra√ß√µes foram bem-sucedidas
        """
        logger.info("üîÑ Executando migra√ß√µes...")
        
        try:
            # Comando para executar migra√ß√µes
            if sys.platform == 'win32':
                python_cmd = str(self.venv_path / 'Scripts' / 'python.exe')
            else:
                python_cmd = str(self.venv_path / 'bin' / 'python')
            
            cmd = [python_cmd, 'manage.py', 'migrate', '--noinput']
            
            result = subprocess.run(cmd, capture_output=True, text=True, cwd=self.project_root)
            
            if result.returncode == 0:
                logger.info("‚úÖ Migra√ß√µes executadas com sucesso")
                return True
            else:
                logger.error(f"‚ùå Erro nas migra√ß√µes: {result.stderr}")
                return False
                
        except Exception as e:
            logger.error(f"‚ùå Erro ao executar migra√ß√µes: {e}")
            return False
    
    def _collect_static_files(self) -> bool:
        """
        Coleta arquivos est√°ticos.
        
        Returns:
            bool: True se coleta foi bem-sucedida
        """
        logger.info("üìÅ Coletando arquivos est√°ticos...")
        
        try:
            if sys.platform == 'win32':
                python_cmd = str(self.venv_path / 'Scripts' / 'python.exe')
            else:
                python_cmd = str(self.venv_path / 'bin' / 'python')
            
            cmd = [python_cmd, 'manage.py', 'collectstatic', '--noinput']
            
            result = subprocess.run(cmd, capture_output=True, text=True, cwd=self.project_root)
            
            if result.returncode == 0:
                logger.info("‚úÖ Arquivos est√°ticos coletados com sucesso")
                return True
            else:
                logger.error(f"‚ùå Erro ao coletar arquivos est√°ticos: {result.stderr}")
                return False
                
        except Exception as e:
            logger.error(f"‚ùå Erro ao coletar arquivos est√°ticos: {e}")
            return False
    
    def _restart_services(self) -> bool:
        """
        Reinicia servi√ßos necess√°rios.
        
        Returns:
            bool: True se reinicializa√ß√£o foi bem-sucedida
        """
        logger.info("üîÑ Reiniciando servi√ßos...")
        
        try:
            # Lista de servi√ßos para reiniciar
            services = ['gunicorn', 'celery', 'redis']
            
            for service in services:
                try:
                    # Tentar reiniciar servi√ßo (pode falhar se n√£o estiver rodando)
                    if sys.platform == 'win32':
                        subprocess.run(['net', 'stop', service], capture_output=True)
                        subprocess.run(['net', 'start', service], capture_output=True)
                    else:
                        subprocess.run(['sudo', 'systemctl', 'restart', service], capture_output=True)
                    
                    logger.info(f"‚úÖ Servi√ßo {service} reiniciado")
                except Exception as e:
                    logger.warning(f"‚ö†Ô∏è  N√£o foi poss√≠vel reiniciar {service}: {e}")
            
            return True
            
        except Exception as e:
            logger.error(f"‚ùå Erro ao reiniciar servi√ßos: {e}")
            return False
    
    def _health_check(self) -> bool:
        """
        Verifica se a aplica√ß√£o est√° funcionando corretamente.
        
        Returns:
            bool: True se aplica√ß√£o est√° saud√°vel
        """
        logger.info("üè• Verificando sa√∫de da aplica√ß√£o...")
        
        try:
            # Verificar se o servidor est√° respondendo
            import requests
            
            # URL de health check (se implementado)
            health_url = os.environ.get('HEALTH_CHECK_URL', 'http://localhost:8000/api/health/')
            
            response = requests.get(health_url, timeout=10)
            
            if response.status_code == 200:
                logger.info("‚úÖ Aplica√ß√£o est√° saud√°vel")
                return True
            else:
                logger.error(f"‚ùå Aplica√ß√£o n√£o est√° saud√°vel: {response.status_code}")
                return False
                
        except Exception as e:
            logger.error(f"‚ùå Erro na verifica√ß√£o de sa√∫de: {e}")
            return False


def main():
    """
    Fun√ß√£o principal do script de deploy.
    """
    if len(sys.argv) > 1:
        project_root = sys.argv[1]
    else:
        project_root = None
    
    deployer = ProductionDeployer(project_root)
    
    if deployer.deploy():
        logger.info("üéâ Deploy conclu√≠do com sucesso!")
        sys.exit(0)
    else:
        logger.error("üí• Deploy falhou!")
        sys.exit(1)


if __name__ == '__main__':
    main()

